/*
 * Generated by ./misc/optlib2c from optlib/man.ctags, Don't edit this manually.
 */
#include "general.h"
#include "parse.h"
#include "routines.h"
#include "field.h"
#include "xtag.h"


static void initializeManParser (const langType language)
{
	addLanguageOptscriptToHook (language, SCRIPT_HOOK_PRELUDE,
		"{{    % /replace SCOPE-ACTION -\n"
		"    % /push SCOPE-ACTION -\n"
		"    /scope-action {\n"
		"        /replace eq {\n"
		"             _scopetop pop 1 /start _matchloc _matchloc2line dup 2 gt {\n"
		"                 2 sub end:\n"
		"             } {\n"
		"                 pop\n"
		"                 pop\n"
		"             } ifelse\n"
		"             _scopepop\n"
		"        } if\n"
		"\n"
		"        _scopetop {\n"
		"            . exch scope:\n"
		"        } if\n"
		"        . _scopepush\n"
		"    } def\n"
		"}}");

	addLanguageRegexTable (language, "main");
	addLanguageRegexTable (language, "section");
	addLanguageRegexTable (language, "sectionheading");
	addLanguageRegexTable (language, "EOF");
	addLanguageRegexTable (language, "SKIP");
	addLanguageRegexTable (language, "REST");
	addLanguageRegexTable (language, "GUARD");

	addLanguageTagMultiTableRegex (language, "main",
	                               "^([^\n.]|\\.[^\nst])[^\n]*\n",
	                               "", "", "{icase}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^\\.TH[\t ]+\"([^\"]+)\"[^\n]*\n",
	                               "\\1", "t", "{icase}{scope=set}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^\\.TH[\t ]+([^\t \n]+)[^\n]*\n",
	                               "\\1", "t", "{icase}{scope=set}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^\\.SH[\t ]+\"([^\"\n]+)\"[^\n]*\n",
	                               "\\1", "s", "{icase}{scope=push}{tenter=section}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^\\.SH[\t ]+([^\n]+)\n",
	                               "\\1", "s", "{icase}{scope=push}{tenter=section}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^\\.SH[\t ]*\n",
	                               "", "", "{icase}{tenter=sectionheading}"
		"{{\n"
		"    /push\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^[^\n]*\n|[^\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^",
	                               "", "", "{scope=clear}{tquit}", NULL);
	addLanguageTagMultiTableRegex (language, "section",
	                               "^([^\n.]|\\.[^\nst])[^\n]*\n",
	                               "", "", "{icase}", NULL);
	addLanguageTagMultiTableRegex (language, "section",
	                               "^\\.SH[\t ]+\"([^\"\n]+)\"[^\n]*\n",
	                               "\\1", "s", "{icase}{scope=replace}", NULL);
	addLanguageTagMultiTableRegex (language, "section",
	                               "^\\.SH[\t ]+([^\n]+)\n",
	                               "\\1", "s", "{icase}{scope=replace}", NULL);
	addLanguageTagMultiTableRegex (language, "section",
	                               "^\\.SH[\t ]*\n",
	                               "", "", "{icase}{tenter=sectionheading}"
		"{{\n"
		"    /replace\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "section",
	                               "^[^\n]*\n|[^\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "section",
	                               "^",
	                               "", "", "{scope=clear}{tquit}", NULL);
	addLanguageTagMultiTableRegex (language, "sectionheading",
	                               "^[ \t]*([^\n]+)\n",
	                               "\\1", "s", "{tleave}"
		"{{\n"
		"    scope-action\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "sectionheading",
	                               "^[^\n]*\n|[^\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "sectionheading",
	                               "^",
	                               "", "", "{scope=clear}{tquit}", NULL);
	addLanguageTagMultiTableRegex (language, "EOF",
	                               "^",
	                               "", "", "{scope=clear}{tquit}", NULL);
	addLanguageTagMultiTableRegex (language, "SKIP",
	                               "^[^\n]*\n|[^\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "REST",
	                               "^[^\n]*\n|[^\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "REST",
	                               "^",
	                               "", "", "{scope=clear}{tquit}", NULL);
	addLanguageTagMultiTableRegex (language, "GUARD",
	                               "^([^\n.]|\\.[^\nst])[^\n]*\n",
	                               "", "", "{icase}", NULL);
}

extern parserDefinition* ManParser (void)
{
	static const char *const extensions [] = {
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"3pm",
		"3stap",
		"7stap",
		NULL
	};

	static const char *const aliases [] = {
		NULL
	};

	static const char *const patterns [] = {
		NULL
	};

	static kindDefinition ManKindTable [] = {
		{
		  true, 't', "title", "titles",
		},
		{
		  true, 's', "section", "sections",
		},
	};

	parserDefinition* const def = parserNew ("Man");

	def->enabled       = true;
	def->extensions    = extensions;
	def->patterns      = patterns;
	def->aliases       = aliases;
	def->method        = METHOD_NOT_CRAFTED|METHOD_REGEX;
	def->useCork       = CORK_QUEUE;
	def->kindTable     = ManKindTable;
	def->kindCount     = ARRAY_SIZE(ManKindTable);
	def->initialize    = initializeManParser;

	return def;
}
