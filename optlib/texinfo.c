/*
 * Generated by ./misc/optlib2c from optlib/texinfo.ctags, Don't edit this manually.
 */
#include "general.h"
#include "parse.h"
#include "routines.h"
#include "field.h"
#include "xtag.h"
#include "param.h"


typedef enum {
	K_ANCHOR,
	K_ALIAS,
	K_FLAG,
	K_MACRO,
	K_MENU,
	K_NODE,
	K_MENTRY,
	K_CHAPTER,
	K_SECTION,
	K_SUBSECTION,
	K_SUBSUBSECTION,
	K_TITLE,
	K_SUBTITLE,
	K_MACROPARAM,
	K_INFO,
	K_TEXINFO,
} TexinfoKind;


static void initializeTexinfoParser (const langType language)
{
	addLanguageOptscriptToHook (language, SCRIPT_HOOK_PRELUDE,
		"{{    /LispLang /LispLang _param not {\n"
		"        (EmacsLisp)\n"
		"    } if def\n"
		"\n"
		"    /kindTable [\n"
		"        /title /chapter /section /subsection /subsubsection\n"
		"    ] def\n"
		"\n"
		"    % cork:int DEPTHFORCORK depth:int\n"
		"    /depthForCork {\n"
		"        :kind kindTable exch _aindex pop\n"
		"    } def\n"
		"\n"
		"    % endline:int goal:int scopePopUpTo -\n"
		"    /scopePopUpTo {\n"
		"        {\n"
		"            _scopetop {\n"
		"                dup\n"
		"                % endline goal scope scope\n"
		"                depthForCork 2 index ge {\n"
		"                    % endline goal scope\n"
		"                    2 index end:\n"
		"                    _scopepop\n"
		"                } {\n"
		"                    pop\n"
		"                    exit\n"
		"                } ifelse\n"
		"            } {\n"
		"                exit\n"
		"            } ifelse\n"
		"        } loop\n"
		"        pop\n"
		"        pop\n"
		"    } def\n"
		"\n"
		"    % - SCOPEACTION -\n"
		"    /scopeAction {\n"
		"        . :line 1 sub . depthForCork scopePopUpTo\n"
		"        _scopetop {\n"
		"        . exch scope: . _scopepush\n"
		"        } {\n"
		"            . _scopepush\n"
		"        } ifelse\n"
		"    } def\n"
		"}}");

	addLanguageRegexTable (language, "main");
	addLanguageRegexTable (language, "macro");
	addLanguageRegexTable (language, "macroparam");
	addLanguageRegexTable (language, "comment");
	addLanguageRegexTable (language, "menu");
	addLanguageRegexTable (language, "linecomment");
	addLanguageRegexTable (language, "blockcomment");
	addLanguageRegexTable (language, "blockcommentbody");

	addLanguageTagMultiTableRegex (language, "main",
	                               "^[^@]+",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@[^achilmnust][^@]*",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^(?:@c|@comment)[[:space:]]+[^\n]*",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@ignore[[:space:]]*",
	                               "", "", "p{tenter=blockcommentbody}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@menu",
	                               "", "M", "p{tenter=menu}{_anonymous=menu}{scope=push}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@node[[:space:]]+([^,\n]+)(?:,[[:space:]]+(?:[^,\n]+),[[:space:]]+(?:[^,\n]+),[[:space:]]+([^,\n]+))?[[:space:]]*\n?",
	                               "\\1", "n", "p"
		"{{\n"
		"    \\2 false ne {\n"
		"        .\n"
		"        \\2 /node @2 _tag _commit dup /upper _assignrole\n"
		"        scope:\n"
		"    } if\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@macro[[:space:]]+([^[:space:]\\{]+)[[:space:]]*",
	                               "\\1", "m", "p{tenter=macro}{scope=push}"
		"{{\n"
		"    . [ ({)\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@(chapter|unnumbered|appendix|chapheading)[[:space:]]+([^\n]+)\n?",
	                               "\\2", "c", "p"
		"{{\n"
		"    scopeAction\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@(section|unnumberedsec|appendixsec|heading)[[:space:]]+([^\n]+)\n?",
	                               "\\2", "s", "p"
		"{{\n"
		"    scopeAction\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@(subsection|unnumberedsubsec|appendixsubsec|subheading)[[:space:]]+([^\n]+)\n?",
	                               "\\2", "u", "p"
		"{{\n"
		"    scopeAction\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@(subsubsection|unnumberedsubsubsec|appendixsubsubsec|subsubheading)[[:space:]]+([^\n]+)\n?",
	                               "\\2", "b", "p"
		"{{\n"
		"    scopeAction\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@setfilename[[:space:]]+([^\n]+)\n?",
	                               "\\1", "I", "p", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@settitle[[:space:]]+([^\n]+)\n?",
	                               "\\1", "T", "p"
		"{{\n"
		"    scopeAction\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@subtitle[[:space:]]+([^\n]+)\n?",
	                               "\\1", "U", "p{scope=ref}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@anchor[[:space:]]*\\{([^\\}]+)\\}",
	                               "\\1", "a", "p{scope=ref}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@set[[:space:]]+([-a-zA-Z_0-9][^[:space:]@^<>~`^+]*)",
	                               "\\1", "f", "p{scope=ref}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@include[[:space:]]+([^\n]+)[[:space:]]*\n?",
	                               "\\1", "X", "p{_role=included}{scope=ref}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@alias[[:space:]]+([^[:space:]=]+)[[:space:]]*=[^\n]*\n",
	                               "\\1", "A", "p{scope=ref}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@tex[[:space:]]*\n(.*)\n@end[[:space:]]+tex",
	                               "", "", "p{_guest=Tex,1start,1end}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^@lisp[[:space:]]*\n(.*)\n@end[[:space:]]+lisp",
	                               "", "", "p"
		"{{\n"
		"    LispLang @1 1@ _makepromise { pop } if\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^.",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "macro",
	                               "^\\{[[:space:]]*",
	                               "", "", "p{tenter=macroparam}", NULL);
	addLanguageTagMultiTableRegex (language, "macro",
	                               "^(?:@c|@comment)[[:space:]]+[^\n]*",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "macro",
	                               "^@ignore[[:space:]]*",
	                               "", "", "p{tenter=blockcommentbody}", NULL);
	addLanguageTagMultiTableRegex (language, "macro",
	                               "^@end[[:space:]]+macro",
	                               "", "", "p{tleave}{scope=pop}"
		"{{\n"
		"    % drop the last (,)\n"
		"    dup (,) eq {\n"
		"        pop\n"
		"    } if\n"
		"    % does the macro take parameters?\n"
		"    dup ({) eq {\n"
		"        % No.\n"
		"    % pop . [ ({)\n"
		"        pop pop pop\n"
		"    } {\n"
		"        % Yes. build signature string and assign it to thet tag for macro.\n"
		"        (}) _buildstring signature:\n"
		"    } ifelse\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "macro",
	                               "^[^\n]+",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "macro",
	                               "^.",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "macroparam",
	                               "^\\}",
	                               "", "", "p{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "macroparam",
	                               "^([^[:space:],\\}]+)(?:[[:space:],]*)",
	                               "\\1", "z", "p{scope=ref}"
		"{{\n"
		"    \\1 (,)\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "macroparam",
	                               "^.",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "comment",
	                               "^(?:@c|@comment)[[:space:]]+[^\n]*",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "comment",
	                               "^@ignore[[:space:]]*",
	                               "", "", "p{tenter=blockcommentbody}", NULL);
	addLanguageTagMultiTableRegex (language, "menu",
	                               "^[*][[:space:]]*(?:\\(([^\\)]+)\\))?[[:space:]]*([^[:space:]\\(:][^:]*):(?:([:])|[[:space:]]*(?:\\(([^\\)]+)\\))?[[:space:]]*([^[:space:]\\(:.][^.]*)[.])[[:space:]]*[^\n]*\n",
	                               "\\2", "e", "p{scope=ref}"
		"{{\n"
		"    \\1 false ne {\n"
		"        \\1 /info @1 _tag _commit dup /referenced _assignrole true\n"
		"    } {\n"
		"        \\4 false ne {\n"
		"            \\4 /info @4 _tag _commit dup /referenced _assignrole true\n"
		"    } {\n"
		"        false\n"
		"        } ifelse\n"
		"    } ifelse\n"
		"    \\3 false eq {\n"
		"        \\5 /node @5 _tag _commit\n"
		"    } {\n"
		"        \\2 /node @2 _tag _commit\n"
		"    } ifelse\n"
		"    dup /menu _assignrole\n"
		"    % scope true index\n"
		"    % false cork\n"
		"    exch {\n"
		"        exch scope:\n"
		"    } {\n"
		"        pop\n"
		"    } ifelse\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "menu",
	                               "^[*][[:space:]]*([^[[:space:]\\(:]+):[[:space:]]*\\(([^\\)]+)\\)[.][^\n]*\n",
	                               "\\1", "e", "p{scope=ref}"
		"{{\n"
		"    \\2 /info @2 _tag  _commit dup /referenced _assignrole\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "menu",
	                               "^[*][[:space:]]*\\(([^\\)]+)\\)::[^\n]*\n",
	                               "\\1", "I", "p{scope=ref}{_role=referenced}", NULL);
	addLanguageTagMultiTableRegex (language, "menu",
	                               "^@detailmenu",
	                               "", "M", "p{tenter=menu}{_anonymous=menu}{scope=push}", NULL);
	addLanguageTagMultiTableRegex (language, "menu",
	                               "^@end[[:space:]]+(menu|detailmenu)",
	                               "", "", "p{tleave}{scope=pop}", NULL);
	addLanguageTagMultiTableRegex (language, "menu",
	                               "^[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "menu",
	                               "^.",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "linecomment",
	                               "^(?:@c|@comment)[[:space:]]+[^\n]*",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "blockcomment",
	                               "^@ignore[[:space:]]*",
	                               "", "", "p{tenter=blockcommentbody}", NULL);
	addLanguageTagMultiTableRegex (language, "blockcommentbody",
	                               "^[^@]+",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "blockcommentbody",
	                               "^@end[[:space:]]+ignore[[:space:]]*",
	                               "", "", "p{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "blockcommentbody",
	                               "^.",
	                               "", "", "p", NULL);
}

extern parserDefinition* TexinfoParser (void)
{
	static const char *const extensions [] = {
		"texi",
		"texinfo",
		NULL
	};

	static const char *const aliases [] = {
		NULL
	};

	static const char *const patterns [] = {
		NULL
	};

	static roleDefinition TexinfoNodeRoleTable [] = {
		{ true, "menu", "node name referenced in @menu...@end" },
		{ true, "upper", "node name referenced @node ..., UP" },
	};
	static roleDefinition TexinfoInfoRoleTable [] = {
		{ true, "referenced", "referenced" },
	};
	static roleDefinition TexinfoTexinfoRoleTable [] = {
		{ true, "included", "included with @include command" },
	};
	static kindDefinition TexinfoKindTable [] = {
		{
		  true, 'a', "anchor", "anchors",
		},
		{
		  true, 'A', "alias", "aliases",
		},
		{
		  true, 'f', "flag", "flags",
		},
		{
		  true, 'm', "macro", "macros",
		},
		{
		  true, 'M', "menu", "menus",
		},
		{
		  true, 'n', "node", "nodes",
		  ATTACH_ROLES(TexinfoNodeRoleTable),
		},
		{
		  true, 'e', "mentry", "menu entries",
		},
		{
		  true, 'c', "chapter", "chapters",
		},
		{
		  true, 's', "section", "sections",
		},
		{
		  true, 'u', "subsection", "subsections",
		},
		{
		  true, 'b', "subsubsection", "subsubsections",
		},
		{
		  true, 'T', "title", "titles",
		},
		{
		  true, 'U', "subtitle", "subtitles",
		},
		{
		  false, 'z', "macroparam", "macro parameters",
		},
		{
		  true, 'I', "info", "info file names",
		  ATTACH_ROLES(TexinfoInfoRoleTable),
		},
		{
		  true, 'X', "texinfo", "texinfo files",
		  ATTACH_ROLES(TexinfoTexinfoRoleTable),
		},
	};
	static paramDefinition TexinfoParamTable [] = {
		{
		  .name        = "LispLang",
		  .desc        = "a guest parser running on @lisp...@end areas [EmacsLisp]",
		  .handleParam = NULL,
		},
	};

	parserDefinition* const def = parserNew ("Texinfo");

	def->versionCurrent= 0;
	def->versionAge    = 0;
	def->enabled       = true;
	def->extensions    = extensions;
	def->patterns      = patterns;
	def->aliases       = aliases;
	def->method        = METHOD_NOT_CRAFTED|METHOD_REGEX;
	def->useCork       = CORK_QUEUE;
	def->kindTable     = TexinfoKindTable;
	def->kindCount     = ARRAY_SIZE(TexinfoKindTable);
	def->paramTable    = TexinfoParamTable;
	def->paramCount    = ARRAY_SIZE(TexinfoParamTable);
	def->defaultScopeSeparator = "\"\"";
	def->initialize    = initializeTexinfoParser;

	return def;
}
