/*
 * Generated by ./misc/optlib2c from optlib/xs.ctags, Don't edit this manually.
 */
#include "general.h"
#include "parse.h"
#include "routines.h"
#include "field.h"
#include "xtag.h"


static void initializeXSParser (const langType language)
{
	addLanguageOptscriptToHook (language, SCRIPT_HOOK_PRELUDE,
		"{{  /scope false def\n"
		"  /xsstart false def\n"
		"  /prefix false def\n"
		"  /prefix-length 0 def\n"
		"  /noprefix? /XS.noprefix _extraenabled def\n"
		"  /tag-noprefix false def\n"
		"  % [ (x) (y) (z) ] ARRAY2SIGNATURE (x,y,z)\n"
		"  /array2signature {\n"
		"    mark\n"
		"    ?( 3 -1 roll { ?, } forall dup ?, eq {\n"
		"      pop\n"
		"    } if\n"
		"    ?) _buildstring\n"
		"  } def\n"
		"}}");

	addLanguageRegexTable (language, "init");
	addLanguageRegexTable (language, "main");
	addLanguageRegexTable (language, "func");
	addLanguageRegexTable (language, "keywords");
	addLanguageRegexTable (language, "fheader");
	addLanguageRegexTable (language, "fcode");
	addLanguageRegexTable (language, "freturn");
	addLanguageRegexTable (language, "alias");
	addLanguageRegexTable (language, "pod");

	addLanguageTagMultiTableRegex (language, "init",
	                               "^((?:.*?)[\n]?)[ \t]*(MODULE[ \t]*=)",
	                               "", "", "p{tjump=main}{_guest=C,1start,1end}{_advanceTo=2start}"
		"{{\n"
		"  /xsstart 2 /start _matchloc def\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^[ \t]*MODULE[ \t]*=[ \t]*([^ \t\n]+)([ \t]*PACKAGE[ \t]*=[ \t]*([^ \t\n]+))?([ \t]*PREFIX[ \t]*=[ \t]*([^ \t\n]+))?[^\n]*\n",
	                               "\\1", "m", "p"
		"{{\n"
		"  \\3 false ne {\n"
		"    % Make a tag for the package and set it to the scope.\n"
		"    \\3 /package 3 /start _matchloc _tag _commit dup . scope:\n"
		"  } {\n"
		"    % Make a tag for the module and set it to the scope.\n"
		"    .\n"
		"  } ifelse\n"
		"  /scope exch def\n"
		"\n"
		"  % Record the prefix.\n"
		"  \\5 false ne {\n"
		"    /prefix \\5 def\n"
		"    /prefix-length \\5 length def\n"
		"  } if\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^[ \t]+[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^(?:REQUIRE|BOOT|CASE|PREINIT|INPUT|INIT|CODE|PPCODE|OUTPUT|CLEANUP|ALIAS|ATTRS|PROTOTYPES|PROTOTYPE|VERSIONCHECK|INCLUDE_COMMAND|SCOPE|INTERFACE|INTERFACE_MACRO|C_ARGS|POSTCALL|OVERLOAD|FALLBACK|EXPORT_XSUB_SYMBOLS)[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^INCLUDE:[ \t]*([^|\n]+?)[ \t]*\\|?\n",
	                               "\\1", "M", "p{_role=included}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^([A-Za-z_][^\n]*?)[ \t]*\n",
	                               "", "", "p{tenter=func}"
		"{{\n"
		"  % return type\n"
		"  \\1 dup _normalize_spaces! _chop_space\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^=[^\n]+\n",
	                               "", "", "p{tenter=pod}{_guest=Pod,0start,}{_advanceTo=0end}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^()",
	                               "", "", "p{tquit}"
		"{{\n"
		"  xsstart false ne {\n"
		"    (CPreProcessor) xsstart 1 /start _matchloc _makepromise { pop } if\n"
		"  } if\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "func",
	                               "^(?:REQUIRE|BOOT|CASE|PREINIT|INPUT|INIT|CODE|PPCODE|OUTPUT|CLEANUP|ALIAS|ATTRS|PROTOTYPES|PROTOTYPE|VERSIONCHECK|INCLUDE_COMMAND|SCOPE|INTERFACE|INTERFACE_MACRO|C_ARGS|POSTCALL|OVERLOAD|FALLBACK|EXPORT_XSUB_SYMBOLS)[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "func",
	                               "^#[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "func",
	                               "^([A-Za-z_][a-zA-Z0-9_]*)[ \t]*\\([^;\n]*;?\n",
	                               "\\1", "f", "p{tjump=fheader}{scope=push}"
		"{{\n"
		"  % function name\n"
		"  count 0 gt {\n"
		"    noprefix? prefix false ne and {\n"
		"      \\1 prefix _strstr {\n"
		"        0 eq {\n"
		"          prefix-length \\1 length prefix-length sub 0 string _copyinterval\n"
		"          % type name-sans-prefix\n"
		"          /function 1 /start _matchloc _tag _commit\n"
		"          % for attaching signature later\n"
		"          dup /tag-noprefix exch def\n"
		"          dup /XS.noprefix _markextra\n"
		"          dup scope scope:\n"
		"          % type tag\n"
		"          1 index\n"
		"          % type tag type\n"
		"          typeref:\n"
		"        } if\n"
		"      } {\n"
		"        pop\n"
		"      } ifelse\n"
		"    } if\n"
		"    % Fill the scope: field.\n"
		"    . scope scope:\n"
		"    % if a return type is on the stack, set it to typeref: field.\n"
		"    % Should we consdier \"struct\", \"union\", and \"enum\" here?\n"
		"    . exch typeref:\n"
		"  } if\n"
		"  % For gathering signatures\n"
		"  [\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "func",
	                               "^[^\n]*\n",
	                               "", "", "p{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "func",
	                               "^.",
	                               "", "", "p{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "keywords",
	                               "^(?:REQUIRE|BOOT|CASE|PREINIT|INPUT|INIT|CODE|PPCODE|OUTPUT|CLEANUP|ALIAS|ATTRS|PROTOTYPES|PROTOTYPE|VERSIONCHECK|INCLUDE_COMMAND|SCOPE|INTERFACE|INTERFACE_MACRO|C_ARGS|POSTCALL|OVERLOAD|FALLBACK|EXPORT_XSUB_SYMBOLS)[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "fheader",
	                               "^[ \t]+ALIAS:\n",
	                               "", "", "p{tenter=alias}", NULL);
	addLanguageTagMultiTableRegex (language, "fheader",
	                               "^#[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "fheader",
	                               "^[ \t]+(?:REQUIRE|BOOT|CASE|PREINIT|INPUT|INIT|CODE|PPCODE|OUTPUT|CLEANUP|ALIAS|ATTRS|PROTOTYPES|PROTOTYPE|VERSIONCHECK|INCLUDE_COMMAND|SCOPE|INTERFACE|INTERFACE_MACRO|C_ARGS|POSTCALL|OVERLOAD|FALLBACK|EXPORT_XSUB_SYMBOLS)[^\n]*\n",
	                               "", "", "p{tjump=fcode}", NULL);
	addLanguageTagMultiTableRegex (language, "fheader",
	                               "^[ \t]+([^=;\n]*)(=[^;\n]+)?;?\n",
	                               "", "", "p"
		"{{\n"
		"  \\1 dup _normalize_spaces! _chop_space\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "fheader",
	                               "^[^\n]*\n?",
	                               "", "", "p{tleave}{_advanceTo=0start}{scope=pop}"
		"{{\n"
		"  ] _scopetop {\n"
		"    exch array2signature\n"
		"    % tag signature\n"
		"    dup 3 1 roll\n"
		"    % signature tag signature\n"
		"    signature:\n"
		"    tag-noprefix false eq {\n"
		"        % signature\n"
		"        pop\n"
		"    } {\n"
		"        tag-noprefix exch signature:\n"
		"        /tag-noprefix false def\n"
		"    } ifelse\n"
		"  } {\n"
		"    pop\n"
		"  } ifelse\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "fcode",
	                               "^#[^\n]*\n",
	                               "", "", "p", NULL);
	addLanguageTagMultiTableRegex (language, "fcode",
	                               "^[^\n]*\n?",
	                               "", "", "p{tleave}{_advanceTo=0start}{scope=pop}"
		"{{\n"
		"  ] _scopetop {\n"
		"    exch array2signature\n"
		"    % tag signature\n"
		"    dup 3 1 roll\n"
		"    % signature tag signature\n"
		"    signature:\n"
		"    tag-noprefix false eq {\n"
		"        % signature\n"
		"        pop\n"
		"    } {\n"
		"        tag-noprefix exch signature:\n"
		"        /tag-noprefix false def\n"
		"    } ifelse\n"
		"  } {\n"
		"    pop\n"
		"  } ifelse\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "freturn",
	                               "^[^\n]*\n?",
	                               "", "", "p{tleave}{_advanceTo=0start}{scope=pop}"
		"{{\n"
		"  ] _scopetop {\n"
		"    exch array2signature\n"
		"    % tag signature\n"
		"    dup 3 1 roll\n"
		"    % signature tag signature\n"
		"    signature:\n"
		"    tag-noprefix false eq {\n"
		"        % signature\n"
		"        pop\n"
		"    } {\n"
		"        tag-noprefix exch signature:\n"
		"        /tag-noprefix false def\n"
		"    } ifelse\n"
		"  } {\n"
		"    pop\n"
		"  } ifelse\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "alias",
	                               "^[ \t]+([^= \t]+)[ \t]*=[^\n]*\n",
	                               "\\1", "a", "p{scope=ref}", NULL);
	addLanguageTagMultiTableRegex (language, "alias",
	                               "^",
	                               "", "", "p{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "pod",
	                               "^=cut[^\n]*\n",
	                               "", "", "p{_guest=,,0start}{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "pod",
	                               "^[^\n]*\n",
	                               "", "", "p", NULL);
}

extern parserDefinition* XSParser (void)
{
	static const char *const extensions [] = {
		"xs",
		NULL
	};

	static const char *const aliases [] = {
		NULL
	};

	static const char *const patterns [] = {
		NULL
	};

	static roleDefinition XSModuleFileRoleTable [] = {
		{ true, "included", "included with INCLUDE keyword" },
	};
	static kindDefinition XSKindTable [] = {
		{
		  true, 'm', "module", "modules",
		},
		{
		  true, 'p', "package", "packages",
		},
		{
		  true, 'f', "function", "functions",
		},
		{
		  true, 'a', "alias", "aliases",
		},
		{
		  true, 'M', "moduleFile", "module files",
		  ATTACH_ROLES(XSModuleFileRoleTable),
		},
	};
	static xtagDefinition XSXtagTable [] = {
		{
		  .enabled     = true,
		  .name        = "noprefix",
		  .description = "include functions name with prefix removed",
		},
	};

	parserDefinition* const def = parserNew ("XS");

	def->versionCurrent= 0;
	def->versionAge    = 0;
	def->enabled       = true;
	def->extensions    = extensions;
	def->patterns      = patterns;
	def->aliases       = aliases;
	def->method        = METHOD_NOT_CRAFTED|METHOD_REGEX;
	def->useCork       = CORK_QUEUE;
	def->kindTable     = XSKindTable;
	def->kindCount     = ARRAY_SIZE(XSKindTable);
	def->xtagTable     = XSXtagTable;
	def->xtagCount     = ARRAY_SIZE(XSXtagTable);
	def->initialize    = initializeXSParser;

	return def;
}
